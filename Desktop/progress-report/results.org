#+title: Developing a tool to generate large-scale PT networks
#+subtitle: ENG4701 Project Proposal \\
#+subtitle: Supervisors: Prof. Le Hai Vu, Dr. Ky Tri Nguyen
#+setupfile: setupfile.org
#+OPTIONS: H:5 num:t
#+latex: \definecolor{bg}{rgb}{0.95,0.95,0.95}
# TODO: make links blue
#+latex: \pagebreak
* Introduction
Network simulation allows researchers, modellers and policy makers to answer questions about road networks. They can manipulate parts of a road network, possibly by adding new infrastructure, and see the effects on the overall network after simulation is completed. There are multiple tools available for network simulation, but our focus will be on open-source software only.

=MATSim= is chosen as the ‘ecosystem’ of focus for this research. =MATSim= requires us to provide an appropriate road network on which to operate. It comes with tools to generate a road network from raw, widely accessible OpenStreetMap (OSM) data.

Once the road network is generated, data related to public transport (PT) infrastructure must be processed and added accordingly. The data for this comes from GTFS feeds, which contain information about the scheduling and routes for public transit lines. This data is commonly available for places with developed infrastructure [cite:@rieserModelingPublicTransport2016].

For a given route, the stops along the route must be ‘snapped’ to nodes on the network. Following this, the stops must be connected by a sequence of links to be followed by the PT vehicle. This requires a routing implementation which will need to run (at least once) for each stop-to-stop connection.

It may be feasible to manually create these connections for small, rural PT networks, but for large city-scale networks this would be too expensive compared to an automated solution [cite:@polettiPublicTransitMapping2017].

There is no 'best practice' or 'perfect method' for undertaking these tasks. Pitfalls abound, and poor decisions at any stage can affect the simulation. Trains do not follow the road network, so new links and nodes are added exclusively for this mode. Buses do follow the road network, which means there is an interdependence between buses and other road users. If stops are added incorrectly and routes are not accurate, the simulation will suffer in its accuracy. =MATSim= was initially developed to model private car usage, so the provisions for modelling PT were added later.

=MATSim= can make use of data which some network generators may be ignoring, such as the routes that PT vehicles would take on the network & the attributes of the links contained in these routes. Some methods do not produce the detailed output necessary for modelling the interaction between private traffic and PT vehicles [cite:@ordonezSemiAutomaticToolBus2016].

While =MATSim= may be popular for research activities, it is prudent to hedge against changes in practice. Wide compatibility is desirable, so that the output format can be easily switched. Networks can then easily be generated for different tools.
There is a need to review best practices for network generation so that policy decisions regarding PT may be accurately assessed. After this, it is necessary to design and build a tool which incorporates these best practices.
* Aims and Objectives
** Research Questions
+ What is the best way to generate large scale PT networks?
+ What improvements can be made to existing network generation tools?
** Aims
+ To review existing tools available for =MATSim= network generation, with a focus on PT network generation
+ To implement a tool which adds topographically correct public transit data to =MATSim= networks
** Objectives
+ To choose 3-4 open-source network generator tools to evaluate
+ To generate networks using each tool and evaluate them from a user perspective
+ To evaluate the networks generated by each tool
+ To design and develop a better PT network generator tool, either by improving an existing tool or building a new one from basic components (at a later stage)
* Literature Review
** Background and overview
=MATSim= is a mesoscopic, multi-agent transport simulation library. It is significantly different compared to traditional four-step model, which have been 'essentially institutionalized' since the 1960s [cite:@mcnallyFourStepModel2000]. Its production started (and still continues) with Kai Nagel - whose previous work on the TRANSIMS project would form the kernel and architecture of =MATSim= [cite:@nagelHistoryMATSim2016]. Its use of 'agents', with real plans and activities to be executed in the simulation, is what sets it apart from the ubiquitous four-step model.

In its initial state, =MATSim= did not allow PT modelling, as its focus was on private car traffic only. Provisions for realistic PT simulation were made by Rieser in 2010. His extension of the QSim module enabled more detailed simulation of PT vehicles along fixed routes with a given schedule [cite:@rieserModelingPublicTransport2016]. Before this implementation, agents following 'non-car' plans would be teleported between origins and destinations, with appropriate time offsets added to indicate time spent in transit. Interaction between private cars and PT vehicle still was not modelled, and both ran on separate networks [cite:@boschMultiModalNetworkMATSim2015]. Rieser also proposed further work:

+ The inclusion of more detailed interactions between different forms of traffic
+ Finer detailing of simulation, like the capacity of PT vehicles, overcrowding effects and PT vehicles being caught in congestion

Further improvements were made in 2018, addressing shortcomings due to the simplified initial PT implementation [cite:@rieserAddingRealismEfficiency2018]. While building a =MATSim= model for Swiss Federal Railways, the researchers found the following issues:

+ PT vehicles would often not arrive on time, but too early or late depending on the specified speeds on the links
+ PT vehicles might block each other on links, leading to additional delays, where in reality they could just pass each other

The proposed 'deterministic PT simulation' aimed to solve these issues by forcing the transit vehicles to serve the stops strictly according to schedule. This implementation is more suited to modelling trains, where network congestion is less likely to cause scheduling issues. While solving the listed issues, interaction with private traffic is not supported in this solution.

Rieser's implementation seems to have endured until at least 2016, where the =MATSim= textbook describes the same logic first presented in his 2010 thesis [cite:@horniMultiAgentTransportSimulation2022].

Researchers at TU Berlin added further realism in 2021 with their work on =MATSim='s existing GTFS converter - used to derive scheduling and vehicle information from public PT information feeds. Their work allowed bunching phenomenon and delay propagation to be represented by the simulation. They also implemented vehicle-looping, whereas previously a new vehicle was generated to begin each PT route and effectively 'vanished' at the end of its journey. It is unclear whether these changes were taken up by the main branch of =MATSim=.

The task of PT network generation is already well supported by inbuilt =MATSim= tools. =GTFS2MATSim=, written by Zilske to "convert GTFS into a =MATSim= transit schedule" is available as an extension [cite:@matsimMATSimExtensions2022]. =GTFS2TransitSchedule= is also available for the same purpose [cite:@ordonezSemiAutomaticToolBus2016]. These tools both generate an unmapped =MATSim= transit schedule. 'Unmapped' refers to the fact that stop sequences and departure times are defined but not the path and reference link for each stop facility.

In 2016 Poletti produced a converter which creates a multi-modal network from GTFS data, much like the two previously mentioned tools [cite:@polettiPublicTransitMapping2016]. This has become pt2matsim and is under active development[fn:4]. The aim with this tool was to create a mapped transit schedule which would conform to the existing road network.

Documentation produced by Simunto in 2019 recommends Poletti's pt2matsim over =GTFS2MATSim= [cite:@rieserMATSimTutorial2019]. It is also preferred in a recent study conducted to assess the implementation of Demand Responsive Transport in Göttingen [cite:@grunickeImplementationCostbenefitAnalysis2020].
** =pt2matsim= overview
=pt2matsim= is a package which contains tools to create mapped PT routes directly from stop sequences found in GTFS data. Routes are a sequence of connected links in the network. Before running, it requires a network to work on. This is normally generated using data from OSM. The GTFS feed has to meet the following minimum requirements:

+ Each transit route has a sequence of stops
+ Each stop has coordinates

The algorithm consists of the following steps, as per a publication from Poletti [cite:@polettiPublicTransitMapping2017]:
1. Identify possible link candidates for each stop (links close to each stop)
2. Create a pseudo-graph using the link candidates as nodes & add a dummy source and destination to this pseudo-graph
3. Calculate the least-cost path between each link candidate pair. These paths are represented by edges in the pseudo-graph, connecting two link candidate nodes.
4. Calculate the pseudo least-cost path from the source node to the destination node in the pseudo-graph. The resulting least-cost path is the best fit link candidate for each stop
5. Create the vehicle route on the network & reference each stop to the link which was contained in the least-cost path on the pseudo-graph in step 4.

The algorithm was validated using GTFS data which did contain polylines[fn:5]  for each route. It was found to be more accurate than the algorithm by Bosch and Ciari [cite:@polettiPublicTransitRoute2017]. While its focus is bus routes, it is also applicable to rail routes. It is limited in that a link cannot be a candidate for two subsequent stops - closely spaced stops can cause issues as a result. Missing links in the network, including missing bus lanes can also cause faulty output.

An additional tool called =genet= is also available to modify the network produced by =pt2matsim= using python. It can also produce visualisations and track changes to the network & public transit schedule[fn:6].
** =GTFS2TransitSchedule= overview
The algorithm proposed by Ordonez and Erath will, for each route (set of stops) [cite:@polettiPublicTransitRoute2017]:

1. Select each stop in sequence
2. If the stop does not have a reference link, create a set of candidate links
3. Identify the shortest path from the previous stop's link to the current stop's link (or set of candidate links)
4. Add this shortest path to the links which constitute the route, with the candidate link contained in the shortest path assigned as the reference link for the stop in question

In contrast with Poletti's algorithm (=pt2matsim=), it only looks at pairs of stops when creating the links for a route. Poletti's algorithm chooses links by calculating link combinations for the whole route, rather than just between subsequent stops.
** =GTFS2MATSim=
This implementation is centred around the use of OSM for the locations of stop facilities and the routes which use them. Line runs (the links used in a route) are taken from OSM and matched against the corresponding routes and stops in the GTFS feed. The GTFS feed provides information about departures & frequencies that is unavailable in the OSM data. This method is useful if users should want to contribute their output back to OSM [cite:@zilskeAngebotsdatenNachfragedatenUnd2018].

The implementation used for the extraction of GTFS data is available online as =GTFS2MATSim=. It produces 'light' transit information without producing network mappings for the routes in the GTFS feed. It outputs an unmapped =MATSim= transit schedule, where interaction between PT and private traffic cannot be modelled.

From here, the OSM data must contain routes that fully encode the network-based line runs. The consistency and completeness of the PT data from OSM is not checked and the preparation is left for users to manually repair or verify.

This method contrasts with both =pt2matsim= and =GTFS2TransitSchedule=, where both tools are agnostic about the source of the road network and do not use PT information from OSM.

Marburger and Kaddoura presented an altered version of =GTFS2MATSim= such that vehicle circulations could be modelled, with vehicles reversing and serving looping routes [cite:@marburgerMoreRealisticSimulation2021]. The base implementation creates a new vehicle for each first departure of each route.
** RMIT network generator overview
This generator was created with a focus on active transport modelling (walking and cycling). Incorporation of PT data was considered as "an optional step", and so its output is not sufficient for detailed PT modelling in =MATSim= [cite:@jafariBuildingRoadNetwork2022].

Like several of the tools discussed previously, it creates an unmapped network and so private vehicles & PT vehicles cannot interact. The PT vehicles operate on their own separate network. The following steps comprise the addition of PT data:

1. PT stations and weekday schedules are extracted from the GTFS feed
2. PT stations are snapped to the nearest existing network nodes
3. Direct links are added between station nodes along each transit route
4. A list of PT vehicles and their schedules are also extracted and written to =MATSim=-compliant XML format
** Evaluating research software
Research software (RS) may be evaluated according to the CDUR procedure, as follows [cite:@gomez-diazEvaluationResearchSoftware2019]:
+ /Citation/: A measure of how well identified the RS is as a research output.
+ /Dissemination/: A function of the permissiveness of the chosen software license, the openness of the distribution platform to contributions and whether the contact details of the authors are available.
+ /Use/: An evaluation of the quality of the provided documentation, tutorials and examples. The time required to run a basic example.
+ /Research/: An assessment of the use of the RS by other research teams & the number of articles produced based of the RS.

Maintainability of RS can be defined as the "possibility to further develop and integrate" the software [cite:@pfeifferTechnicalDebtMaintainability2022]. Software is available to evaluate code-bases by their maintainability. Technical debt (TD) may be defined as the "cost of the effort required to fix problems that remain in the code when an application is released to operation."

Tools are available which attempt to measure the TD of a given code-base. 'Code Climate Quality' assesses a code-base by measuring :

1. argument count (too many arguments per unit),
2. complex logic (too long Boolean expressions),
3. file length (too many lines in a file),
4. identical blocks of code (syntactic code clones),
5. unit complexity (units with too high cognitive complexity),
6. unit count (too many units per modules),
7. method length (too many lines per unit),
8. nested control flow (too deeply nested control structures),
9. return statements (too many return statements per unit), and
10. similar blocks of code (structural code clones).

Each violation of any of the above rules carries a 'time to fix' estimate, which is aggregated per file to assign a score from A to F (A being best, F being worst).

As of the time of writing, there is no tool which purports to analyse code-bases written in the R language. As a result, the RMIT tool (written in R) will not be analysed according to these metrics.
* Methodology
** Overview of general methodology
*To choose 3-4 network generator tools to evaluate*

The 3 initially selected tools should be actively used and accessible to the public (i.e. open-source). They should be in a usable state, since the focus of this project is not to repair, but to improve. The tool should be accessible for improvements, and so should be hosted on a platform which allows open contribution, either through git, email patches or other forms of version control .

*To generate networks using each tool and evaluate the tools from a user perspective*

A thorough review of best practices for evaluating scientific software will be undertaken to determine how to accurately rate the usage and performance of each of the three chosen tools.
Since the focus is on PT, the following =MATSim= inputs (network generator outputs) are desired:

+ network.xml
+ transitSchedule.xml
+ transitVehicles.xml

Networks will be generated using the same OSM data input.
The networks should be cleaned and simplified using the specific methods provided by each of the three tools. Combinations of methods from different tools should also be applied if the ‘in-house’ methods for any one tool are lacking.

*To evaluate the results generated by each tool*

To generate the transitSchedule.xml file, the appropriate stops (or stations) must be first added to the network. Following this, routes are constructed using the links between the stops. Generators should be judged on the speed and accuracy with which they (for a given GTFS feed):

+ Add PT stops to the road network
+ Create routes between these stops

The resulting networks will be judged according to the following criteria:

+ Size of resulting network (including other output files)
+ Time taken to return results
+  An assessment of randomly selected routes

3 routes will be randomly selected from the output and validated against routes obtainable from a consumer trip-planning app (PTV App). The routes selected for review should follow the same links as seen in the app. The number of ‘different’ links compared to the app is collected for review.
The networks are necessary for use in a =MATSim= modelling. Modelling performance will be studied among the three chosen generator tools. For the Melbourne city region, with the same population file input for each simulation run, the results will be validated against real measurements to see which tool yields the most accurate network.

*To create a PT network generator tool, either by modifying an existing tool or building one from basic components*

The results of the preceding analysis will inform the final part of this project. If there is a tool which is very close to what is desired, it should be further improved to make up for anything it lacks. If there is generally not a 'best tool', our findings should inform us in the production of a new tool which will perform better than what is available.
A minimal set of functions and features should be specified so that a working product can be produced as quickly as possible. The tool should be tested using the same methods which were outlined above.
** Network generation, simplification and routing
+ The process can be seen as a 'pipeline', with the output of one step feeding into the next:
  + OSM conversion \rightarrow Cleaning and simplification \rightarrow Routing PT network
+ For each step above, and for each tool, the process is presented below
+ All steps were performed using macOS 12.6, but should easily be adaptable to any GNU/Linux or BSD system
#
*System dependencies*:
+ It is assumed that you have the following dependencies installed on your system using [[https://brew.sh/][brew]], [[https://www.macports.org/install.php][macports]] or another [[https://en.wikipedia.org/wiki/Package_manager][package manager]]:
  + =git=: To clone remote code repositories to your machine ([[https://formulae.brew.sh/formula/git][link]])
  + =maven=: To manage dependencies and to build Java projects ([[https://formulae.brew.sh/formula/maven#default][link]])
  + =openjdk=: To run Java projects using the Java Virtual Machine (JVM) ([[https://formulae.brew.sh/formula/openjdk#default][link]])
  + =r=: The language in which the RMIT network conversion tool is written. We need the interpreter to run the project ([[https://formulae.brew.sh/cask/r#default][link]])
  + =python3=: To install and run =genet=. =Python@3.10= should just work (installed using =pyenv=)
  + =pyenv=: To manage the virtual environment in which =genet= is installed ([[https://formulae.brew.sh/formula/pyenv#default][link]])
    + =pyenv-virtualenv=: For use with =pyenv= ([[https://formulae.brew.sh/formula/pyenv-virtualenv#default][link]])
  + =cbc=: For use in =genet= routing method ([[https://formulae.brew.sh/formula/cbc][link]])
  + IntelliJ IDEA: To use the =MATSim= cleaning and simplification tools
  + =xmlstarlet=: For fixing some issues in the output of certain tools ([[https://formulae.brew.sh/formula/xmlstarlet][link]])
*** OSM conversion
+ First, the network should be converted from =.osm= format to =MATSim .xml= format (according to [[http://www.matsim.org/files/dtd/network_v2.dtd][this XML schema]])
+ Each tool requires some configuration to interpret the OSM tags in the data
  + Since OSM does not enforce uniform tagging across regions, it's necessary to specify how you want the tags to be translated
  + This is normally achieved by modifying a '/config/' file (short for 'configuration') and passing it to the tool at runtime
+ Each tool also needs to know the co-ordinate reference system (CRS) to use when reading the network
  + In this case, the OSM network is referenced to the [[https://epsg.io/28355][EPSG:28355]] CRS
#
+ The *OSM network* is downloaded by switching to an appropriate directory and running the following command:
#+begin_src sh :eval never-export
wget -O melbourne.osm 'https://cloudstor.aarnet.edu.au/plus/s/rLTlQJDRixhyan9/download?path=%2F&files=melbourne.osm'
#+end_src
# TODO: fix line breaking in above listing
**** =genet= :noexport:
# NOTE: not generated - should I do it?
+ =genet= was not yet used to convert the OSM network
**** =pt2matsim=
+ The first step is to clone the =pt2matsim= repo, after switching to an appropriate folder:
#+begin_src sh :eval never-export
git clone https://github.com/matsim-org/pt2matsim
#+end_src

+ Then change directories into the folder that was downloaded:
#+begin_src sh :eval never-export
cd pt2matsim
#+end_src

+ We then use =maven= to download the dependencies and compile a =.jar= file for use in the next step:
#+begin_src sh :eval never-export
mvn clean package
#+end_src

+ Change directory into the =src= folder and generate a default config file (=defaultConfigFile.xml=):
#+begin_src sh :eval never-export
cd src && java -cp ../target/pt2matsim-22.3-shaded.jar:. org.matsim.pt2matsim.run.CreateDefaultOsmConfig defaultConfigFile.xml
#+end_src

+ From here, the config file generated in the last step should be edited to suit your needs.
+ Each parameter has a comment to explain what it does
+ At a minimum, the following parameters need to be configured:
  + =osmFile=: the path to the OSM file (downloaded previously)
  + =outputCoordinateSystem=: the EPSG:* output coordinate system. For our purposes, we use EPSG:28355
  + =outputNetworkFile=: the path and filename of the network output. The name should be suffixed with a =.xml=, ie. =exampleNetwork.xml=
  + =keepPaths=: Recommended to set to =true=
#
+ The next step is to pass this config file to the =Osm2MultimodalNetwork= class, which will generate the required =MATSim= network file:
#+begin_src sh :eval never-export
java -cp ../target/pt2matsim-22.3-shaded.jar:. org.matsim.pt2matsim.run.Osm2MultimodalNetwork ./defaultConfigFile.xml
#+end_src
**** RMIT
+ This converter also performs some cleaning and simplification steps
+ First, inside an appropriate directory, clone the project:
#+begin_src sh :eval never-export
git clone https://github.com/matsim-melbourne/network
cd network
#+end_src

+ Further packages are required on your machine to run this project, you can run the following to install them using brew:
#+begin_src sh :eval never-export
brew install postgres
brew install postgis
brew install gdal
brew install udunits
brew services start postgresql
/usr/local/opt/postgres/bin/createuser -s postgres
#+end_src

+ Install the necessary =r= packages to use the project:
#+begin_src R :eval never-export
install.packages("renv")
renv::restore()
#+end_src

+ If any issues occur, consult the =README.md= in the root directory of the project
#
+ After the prerequisite packages are installed, download the data necessary for the conversion
  + The only necessary input is the =melbourne.osm= file, downloaded at the beginning of this instruction set ([[*OSM conversion][here]])
+ Copy =melbourne.osm= over inside the =data= folder of the project
#
+ Changes to the configuration are made in the =NetworkGenerator.R=
+ The following should be set, at a minimum:
  + =outputCrs=: set to =28355= (for this example)
  + =processOsm=
  + =osmExtract=: set to =T= to use our =melbourn.osm= file
  + =addGtfs=: set to =F=, as GTFS data is added using other tools
  + =gtfs_feed=
  + any output file paths under =# Outputs=
#
+ After the configuration is complete, run the tool with:
#+begin_src sh :eval never-export
Rscript -e 'source("NetworkGenerator.R"); makeNetwork("example")'
#+end_src
+ This will produce the network, in the folder =example=
*** PT file conversion
+ The GTFS specification is used to store data pertaining to public transport routes
+ It comes in a =.zip= file, sometimes called a 'feed', itself containing =.txt= files
+ The =.txt= files follow a [[https://developers.google.com/transit/gtfs/reference][schema]] set by google
+ It is necessary to convert these files into a format that =MATSim= can understand
+ Download the GTFS feed for Melbourne by issuing the following command at the terminal:
#+begin_src sh :eval never-export
wget -O gtfs_au_vic_ptv_20191004.zip 'https://cloudstor.aarnet.edu.au/plus/s/rLTlQJDRixhyan9/download?path=%2F&files=gtfs_au_vic_ptv_20191004.zip'
#+end_src

+ After completion, issue this command to unzip the feed to a folder called =gtfsdir=:
#+begin_src sh :eval never-export
unzip -d gtfsdir gtfs_au_vic_ptv_20191004.zip
#+end_src

+ Copy this folder to be inside the =src= folder mentioned in the methodology for installing and using =pt2matsim= ([[*=pt2matsim=][above]])
#
+ Now run the *schedule converter* (part of =pt2matsim= tooling)
+ This method takes the following arguments:
  + The folder where the unzipped GTFS data resides (=./gtfsdir=)
  + Which service IDs should be used. /One of/:
    + Date formatted in "=yyymmdd="
    + "=dayWithMostServices="
    + "=dayWithMostTrips="
    + "=all="
  + Output coordinate system. (=EPSG:28355= for this example)
  + Output transit schedule file (=./transitSchedule.xml=)
  + Output transit vehicles file (=./transitVehicles.xml=)
+ Here is how to invoke the schedule converter:
#+begin_src sh :eval never-export
java -cp ../target/pt2matsim-22.3-shaded.jar:. org.matsim.pt2matsim.run.Gtfs2TransitSchedule ./gtfsdir "dayWithMostServices" "EPSG:4326" ./transitSchedule.xml ./transitVehicles.xml
#+end_src

+ This will produce =transitSchedule.xml= and =transitVehicles.xml=, both of which will be used universally for the proceeding methods
*** Cleaning and simplification
# TODO: check whether I can get good output from 'IntersectionSimplifier'
+ The resulting network, created in any of the 'OSM conversion' methods, will be quite large and contain many extraneous features
+ 'Cleaning' and 'simplification' are different ideas - but since they are performed in a single 'method' here, we will refer to these concepts interchangeably
+ The output from the *RMIT* tool is already simplified as part of its 'generation' method - but further simplification can be achieved by running it through any of the following tools
**** =genet=
# Installation
+ Genet provides tools to clean and simplify =MATSim= network files
+ Their full (and very well presented) documentation is found [[https://github.com/arup-group/genet/wiki/Usage:-5.3.-Modifying-Network:-Simplification][here]]
+ This method can either be performed in a jupyter notebook, as shown in the documentation, or it can be performed with the script provided in the =genet= repository
#
+ Clone the =genet= repository in an appropriate location on your machine:
#+begin_src sh :eval never-export
git clone https://github.com/arup-group/genet && cd genet
#+end_src

+ Assuming that the prerequisites (mentioned [[*Methodology][here]]) are installed, run the following to create a virtual environment in which to install =genet=:
#+begin_src sh :eval never-export
pyenv install 3.10.7
pyenv shell 3.10.7
pyenv virtualenv 3.10.7 my-genet-env
pyenv activate my-genet-env
#+end_src

+ Install =genet= inside this virtual environment with:
#+begin_src sh :eval never-export
pip install -e .
#+end_src

+ If there are dependency issues, try to run the following, which will upgrade the packages specified for the project in =requirements.txt=:
#+begin_src sh :eval never-export
pip install pip-upgrader
pip-upgrade ./requirements.txt
#+end_src

+ Run the installation step again to see if the issues were resolved
# Cleaning
+ After =genet= is installed, copy the network (generated using any of the tools in section [[OSM conversion]]) =.xml= file and the =simplify_network.py= script into an appropriate directory, like:
#+begin_src sh :eval never-export
mkdir ~/Documents/my-network-dir/
cp ./scripts/simplify_network.py ~/Documents/my-network-dir
cd ~/Documents/my-network-dir
#+end_src

+ Run the simplification script, assuming the network is named =network.xml=
  + Change =-np= (number of threads) to suit your system (1 for each CPU core)
#+begin_src sh :eval never-export
python simplify_network.py -n ./network.xml -p "epsg:28355" -np 10 -od ./genet-out
#+end_src
+ The output will appear in =genet-out=, in this case
+ If the resulting XML file is one one single line, run the following command to fix it and create a new file:
#+begin_src sh :eval never-export
cat network | xmlstarlet fo > newnet.xml
#+end_src
**** =MATSim= tools
+ The =MATSim= tools are to be installed and used from an appropriate IDE, in this case IntelliJ IDEA
+ Refer to the =MATSim= tutorial slides found [[https://www.simunto.com/matsim/tutorials/eifer2019/][here]] for more detailed instructions on installing and setting up the =MATSim= tools, they are comprehensive. The 'day 1' slides have all the necessary information
+ Once the 'example project' is cloned, and IntelliJ has installed the requirements for =MATSim=, make a copy the folder =matsim-example-project/scenarios/equil= and rename it to something like '=melbourne='
+ Copy your network to the new =melbourne= folder
+ Edit the =config.xml= file inside the =melbourne= folder, namely:
  + =coordinateSystem=: Change this to the appropriate one for the network file (EPSG:28355)
  + =inputNetworkFile=: rename this to the name of your network
+ Make a copy of the following file, renaming it to something like =cleaner.java=:
  + =matsim-example-project/src/main/java/org/matsim/project/RunMatsim.java=
  + Here is the file on the remote repository ([[https://github.com/matsim-org/matsim-example-project/blob/master/src/main/java/org/matsim/project/RunMatsim.java][here]])
+ Apply the following patch to the =RunMatsim.java= file, assuming the above names are used:
#+begin_src diff :eval never-export
--- a/src/main/java/org/matsim/project/RunMatsim.java
+++ b/src/main/java/org/matsim/project/RunMatsim.java
@@ -57,7 +57,7 @@ public class RunMatsim{

Config config;
if ( args==null || args.length==0 || args[0]==null ){
- config = ConfigUtils.loadConfig( "scenarios/equil/config.xml" );
+ config = ConfigUtils.loadConfig( "scenarios/melbourne/config.xml" );
} else {
config = ConfigUtils.loadConfig( args );
}
@@ -82,8 +82,23 @@ public class RunMatsim{


// ---
-
- controler.run();
+
+ Network network;
+ network = scenario.getNetwork();
+
+ // ---
+ IntersectionSimplifier ns = new IntersectionSimplifier(30, 2);
+ Network newNetwork =  ns.simplify(network);
+
+ Set<String> mySet = new HashSet<String>();
+ mySet.add("car");
+ mySet.add("bus");
+ mySet.add("train");
+
+ new NetworkSimplifier().run(newNetwork);
+ new MultimodalNetworkCleaner(newNetwork).run(mySet);
+ new NetworkWriter(newNetwork).write("scenarios/melbourne/output/cleaned-simplified-network.xml");
+ // controler.run();
}

}
#+end_src

+ Once these changes are made, with the modified =RunMatsim.java= file open in the IDE, click the green 'run' button in the top toolbar to clean and simplify the network, with outputs in =scenarios/melbourne/output/=
**** Command-line methods :noexport:
# for if network is too large for system
# see if I need this..
+ xmlstarlet
+ sed
*** Routing PT network
**** =pt2matsim=
+ Change directory to =pt2matsim/src=, which was cloned in section [[=pt2matsim=]]
+ Its assumed that the installation steps were completed previously
#
+ Copy the following necessary files to this directory, which were generated previously:
  + =network.xml=
  + =transitSchedule.xml=
  + =transitVehicles.xml=
#
+ Create a default configuration file, =mapperConfig.xml=:
#+begin_src sh :eval never-export
java -cp ../target/pt2matsim-22.3-shaded.jar:. org.matsim.pt2matsim.run.CreateDefaultPTMapperConfig ./mapperConfig.xml
#+end_src
#
+ Edit this new file called '=mapperConfig.xml=' with your favourite text editor, making sure to specify the following at a minimum:
  + =inputNetworkFile=: The relative location of the input network file. In our case this is =./network.xml=
  + =inputScheduleFile=: The relative location of =transitSchedule.xml= (=./transitSchedule.xml=)
  + =outputNetworkFile=: The name of the new network file (=mappedPTNetwork.xml=)
  + =outputScheduleFile=: (=mappedSchedule.xml=)
  + =outputStreetNetworkFile=: Path to output car only network file (=carOnlyNetwork.xml=)
+ Once the above parameters are set, check to see if you need to change any others. For example, increasing the =numOfThreads= will help speed up the computation. In general, 1 thread per physical CPU core gives sufficient speed.
#
+ Run =PublicTransitMapper= with the config file as the argument:
#+begin_src sh :eval never-export
java -cp ../target/pt2matsim-22.3-shaded.jar:. org.matsim.pt2matsim.run.PublicTransitMapper ./mapperConfig.xml
#+end_src
**** =genet=
+ Make a new folder containing the following files:
  + =network.xml= (preferably cleaned beforehand with methods from sections [[OSM conversion]] and [[Cleaning and simplification]])
  + =gtfs-feed.zip= (used in section [[PT file conversion]])
+ Inside the repo for =genet=, copy the script =./scripts/simplify_network.py= to the folder you created
+ Activate the virtual environment in which you installed genet:
#+begin_src sh :eval never-export
pyenv activate my-genet-env
#+end_src

+ Run the PT network router with the following command:
#+begin_src sh :eval never-export
python make_pt_network.py -n ./network.xml -g ./gtfs.zip -gd '20191011' -p 'EPSG:28355' -pp 10 -od ./output
#+end_src

+ If there is an error regarding loading the schedule file, it may be because the transit schedule contains lines without routes
* Project scope, plan and timeline
** Scope
The chosen tools perform many functions to produce the desired output. The construction of the road network is a portion of the work that is performed. PT data addition is performed after this initial construction. The initial road network construction will not be reviewed or reproduced as a part of this project.
No focus is given to active transport in this project. The focus of this project is:

+ Regular road vehicles (cars, trucks etc.)
+ Public transport road vehicles (buses)
+ Trains and trams

The analysis and simulation will be limited to Melbourne’s road and PT network. Any peculiarities resulting from this focus will be clearly stated so that the methods used herein are applicable to other regions.
The tools being reviewed are limited to those that produce output for use in =MATSim= models.
** Plan and timeline
+ Included as \cref{app:A}
* Preliminary results
# talk about how these contribute to achieving aims
# how they test hypothesis and answer research question
# what is my research question again?
# do I have brain damage?
** Capabilities of each tool
+ Each tool lends itself to a different use, but some of their features overlap. The table below should clarify what each tool is able to achieve.

#+caption: Information on the capabilities and use of each tool.
#+ATTR_LATEX: :float nil
|                              | =genet= | =pt2matsim= | =MATSim= tools | RMIT tool |
|------------------------------+---------+-------------+----------------+-----------|
| /Features/  (not exhaustive) |         |             |                |           |
|------------------------------+---------+-------------+----------------+-----------|
| OSM conversion               | y       | y           | y              | y         |
| Cleaning/simplification      | y       | y           | y              | y         |
| PT file conversion           | n       | y           | y              | n         |
| Mapped PT routing            | y       | y           | n              | n         |
| Visualisation                | y       | n           | n              | n         |
|------------------------------+---------+-------------+----------------+-----------|
| /Other/                      |         |             |                |           |
|------------------------------+---------+-------------+----------------+-----------|
| Language                     | Python  | Java        | Java           | R         |
| Modular functions            | y       | y           | ~y[fn:1]       | n         |
| Batch processing             | y       | y           | y              | y         |
| Interactive                  | y       | n           | n              | n         |

** Network genesis
Each of the sections below will outline the creation of each network and the steps taken to generate it. The naming scheme is simple: the network is named after each of the tools used to create it. For example:
+ =OPMG.xml=:
  1. *O*: OpenStreetMap data \rightarrow
  2. *P*: =pt2matsim= network converter \rightarrow
  3. *M*: =MATSim= cleaner/simplifier \rightarrow
  4. *G*: =genet= PT router
#
+ The following legend applies to the tables in this section:
  + *y*: Yes, produced this network
  + *NA*: No, could not produce this network, previous or earlier step(s) not successful
  + *f*: No, could not produce this network, current step not successful
*** OSM Generation  matrix
The network is initiall imported from OpenStreetMap in =.osm= format. For the first step in the process, the tool must convert this OSM network to =MATSim=-compliant XML format. Below is a table containing information on the source and process steps performed on each 'converted' network.
#
#+caption: OSM Generation
#+ATTR_LATEX: :float nil
#+label: tab:gen
| source | tool        | ID |   Links |  Nodes |
|--------+-------------+----+---------+--------|
| OSM    | RMIT        | OR |  434712 | 149010 |
| OSM    | =pt2matsim= | OP | 1561405 | 880162 |
| OSM    | =genet=     | OG |       f |      f |

# Generating a network with =genet= from OSM data yields an error - proceeding without the 'OG' network branch for now
*** Cleaning and simplification matrix
The table below outlines the flow from the network generation step (above) through the 'cleaning and simplification' step.
#
#+caption: Network cleaning
#+label: tab:clean
#+ATTR_LATEX: :float nil
| source | tool     | ID      | Links  | \Delta Links  | Nodes  | \Delta Nodes | time [s] |
|--------+----------+---------+--------+----------+--------+---------+----------|
| OR     | =genet=  | ORG     | NA     | NA       | NA     | NA      |          |
| OP     | =genet=  | OPG     | 206847 | -1354558 | 463636 | -416526 |     2100 |
| OG     | =genet=  | OGG     | NA     | NA       | NA     | NA      |          |
| OP     | =MATSim= | OPM     | 350023 | -1211382 | 269304 | -610858 |       30 |
| OR     | =MATSim= | ORM     | NA     | NA       | NA     | NA      |          |
| OG     | =MATsim= | OGM     | NA     | NA       | NA     | NA      |          |
*** PT file conversion matrix
+ Only one set of GTFS files have been used throughout the routing process
+ These were generated using the method outlined in section [[PT file conversion]].
*** Routing matrix
The table below shows the provenance and some information regarding the final networks created at the end of the pipeline.
#
#+caption: PT routing
#+label: tab:route
#+ATTR_LATEX: :float nil
| source | tool        | ID   | y/NA/f? | time [s] |
|--------+-------------+------+---------+----------|
| ORG    | =pt2matsim= | ORGP | NA      | NA       |
| OPG    | =pt2matsim= | OPGP | f       | NA       |
| OGG    | =pt2matsim= | OGGP | NA      | NA       |
| ORM    | =pt2matsim= | ORMP | NA      | NA       |
| OPM    | =pt2matsim= | OPMP | y       | 120      |
| OGM    | =pt2matsim= | OGMP | NA      | NA       |
| ORG    | =genet=     | ORGG | NA      | NA       |
| OPG    | =genet=     | OPGG | f       | NA       |
| OGG    | =genet=     | OGGG | NA      | NA       |
| ORM    | =genet=     | ORMG | NA      | NA       |
| OPM    | =genet=     | OPMG | f       | NA       |
| OGM    | =genet=     | OGMG | NA      | NA       |

** OSM conversion results
# TODO: add bit in literature review about the capabilities of each tool
# TODO: add links to each tool in the literature review (in the table?)
#
+ The details of the conversion are outlined in section [[Methodology]] for each tool
*** OR :ATTACH:
:PROPERTIES:
:ID:       b8b9d7cd-9818-424c-beaf-7c2bf218da64
:END:
+ Observing 'back-and-forth' links at co-ordinates =392376.15625 / 5794357.5= and elsewhere:
+ Further steps will not use this network. These issues should first be rectified

#+caption: Strange links in the 'OR' network
#+label: fig:ORstrange
#+ATTR_LATEX: :float nil
[[attachment:_20221019_210152OR-strange.png]]
*** OP :ATTACH:
:PROPERTIES:
:ID:       65a8beca-30d4-4129-a66c-881e0eaf555e
:END:
+ Looking at the same location as in Figure [[fig:ORstrange]], the same behaviour is not observed in Figure [[fig:OPnet]].
+ The cleaning appears to have operated normally, producing a network which preserves the necessary detail for modelling.

#+caption: Normal behaviour (OP network)
#+label: fig:OPnet
#+ATTR_LATEX: :float nil
[[attachment:_20221019_210257OPnet.png]]

** Cleaning and Simplification results
*** OPM :ATTACH:
:PROPERTIES:
:ID:       aa23f4ae-0567-4985-a496-a8a925b2992b
:END:
+ Example image of the network links at location =392376.15625 / 5794357.5=, same as in previous figures ([[fig:ORstrange]] and [[fig:OPnet]] above):

#+caption: Cleaned and simplified (OPM network)
#+label: fig:OPMnet
#+ATTR_LATEX: :float nil
[[attachment:_20221019_212050OPMnet.png]]

+ The attributes have been stripped from the network (OSM attributes)
*** OPG :ATTACH:
:PROPERTIES:
:ID:       d87f5bdb-ba5e-47e5-bae7-8db356c74e58
:END:
+ Below is an example of the simplification performed by the =genet= tool
+ Co-ordinates: =392376.15625 / 5794357.5=

#+caption: Genet cleaning/simplification (OPG)
#+label: fig:OPGnet
#+ATTR_LATEX: :float nil
[[attachment:_20221019_220431OPGnet.png]]
** Routing PT network results
*** OPMP :ATTACH:
:PROPERTIES:
:ID:       4d506272-09de-42dc-95ca-f85e6e0ab06d
:END:

+ Below are some examples of the PT routing performed by the =pt2matsim= tool (figure [[fig:OPMPcomp]])
+ On the right of figure [[fig:OPMPcomp]], red links are for car & PT, green links are for PT only, and blue links are for any mode
+ The router seems to not pick up on the train links on the input network and is making 'artificial links' along the stops of the train lines

# TODO: make this a top & bottom picture rather than side by side
#+caption: Comparison of the 'car only' network (/left/) and the 'mapped PT network' (/right/)
#+label: fig:OPMPcomp
#+ATTR_LATEX: :float nil
[[attachment:_20221020_130826OPMPcomp.png]]

# OPMPobvs image:
# car, pt: yellow
# car: light red
# pt: green
# all: blue

+ The routes (visualised in =genet=) seem to mostly follow the road network (fig [[fig:OPMProutes]])
+ The straight-line links are routes which follow the artificial links (visible in fig [[fig:OPMPcomp]])

#+caption: Visualisation of OPMP routes
#+label: fig:OPMProutes
#+ATTR_LATEX: :float nil
[[attachment:_20221020_130954OPMPvisroute.png]]
*** OPGP :noexport:
# did not work
# wonder what it does not like about the genet network...
*** OPGG :noexport:
# in progress, very slow
# cancelled, [[file:~/Library/Mobile Documents/com~apple~CloudDocs/uni4/fyp/fyp-meta.org::*OPGG][commentary here]]
*** OPMG :noexport:
# if OPGG works
# didn't...
** Checking PT routes :ATTACH:
:PROPERTIES:
:ID:       47cd5681-fc12-45e2-8394-0dfaaa7f4374
:END:
The routes shown in the 'OPMP' network are validated against those available from the PTV API. 3 routes were selected and compared to those which are selected from the PTV API. This should give an indication of the accuracy of the routing algorithm. It is only meant to serve as a visual measure to check how well the router performed and to see any shortcomings which can be addressed in future work.
*** Route 305 (bus)
# 4-305-mjp-1,4,305,City (King/Lonsdale Sts) - The Pines,3,FF8200,FFFFFF
# n.schedule['4-305-mjp-1'].plot(data=False)
+ The first selected route is 305, running from The Pines SC to King St/Lonsdale St
+ It is shown in figure [[fig:305ptv]] below:

#+caption: Route 305 - PTV Data
#+label: fig:305ptv
#+ATTR_LATEX: :float nil
[[attachment:_20221020_214430305-PTV.png]]

#
+ On the mapped PT network, OPMP, the route is shown in figure [[fig:305OPMP]] below:

#+caption: Route 305 - OPMP
#+label: fig:305OPMP
#+ATTR_LATEX: :float nil
[[attachment:_20221020_214443305-OPMP-vis.png]]
*** Route 250 (bus) :ATTACH:
+ Route 250 is shown below in figure [[fig:250ptv]]

#+caption: Route 250 - PTV
#+label: fig:250ptv
#+ATTR_LATEX: :float nil
[[attachment:_20221020_222816250-PTV.png]]


+ Figure [[fig:250OPMP]]  shows route 250 for the OPMP network:

#+caption: Route 250 - OPMP
#+label: fig:250OPMP
#+ATTR_LATEX: :float nil
[[attachment:_20221020_222828250-OPMP.png]]
*** Tram 12 :ATTACH:
+ The route for tram 12 is shown in figure [[fig:tram12ptv]] below:

#+caption: Tram 12 - PTV
#+label: fig:tram12ptv
#+ATTR_LATEX: :float nil
[[attachment:_20221020_223933tram12-PTV.png]]

+ Figure [[fig:tram12OPMP]] is the OPMP representation of tram 12's route on the =MATSim= network:

#+caption: Tram 12 - OPMP
#+label: fig:tram12OPMP
#+ATTR_LATEX: :float nil
[[attachment:_20221020_224044tram12-OPMP.png]]
* Discussion
# on the results
    # talk about the validation
    # tool comparison
The preliminary results show that the chosen tools are able to perform well together to produce promising initial output (see section [[Checking PT routes]]).  The initial validation shows that the routing performed by =pt2matsim= is able to closely replicate the shapes published by PTV. There are small deviations, for instance, comparing figures [[fig:305ptv]] and [[fig:305OPMP]], there is a large curving section between Kew East and Clifton Hill. The OPMP 305 route has a straight section here instead. While this is not a failure, the use of such artificial links means that the vehicle will travel 'alone' on this straight section and interaction with other vehicles (cars, other busses) is not modelled.

The overall output in the OPMP network still contained many artificial links (Figure [[fig:OPMProutes]]). This could be due to the routing implementation (in this case =pt2matsim=) not being configured to correctly read the OSM tags for railway links. Further investigation is needed to determine the cause behind these artificial links.

The RMIT tool produced unsatisfactory results using the default configuration (refer to [[fig:ORstrange]]). The network appears to contain links that 'loop around' on themselves, with sharp turns and extraneous links. Further investigation is necessary to determine whether this issue may be rectified. In its current state, the OR network was not fit to pass to further steps in the pipeline, hence the 'NA' values for its children in section [[Network genesis]].

=genet= was unable to convert from OSM to =MATSim= XML format due to an error in the package. =genet= generally was the most problematic in terms of processing steps (conversion, simplification, routing). Several issues occurred during use, halting the program and dumping all the work done before the error occurred. Its visualisation abilities are unmatched by the other tools though, and its ability to represent a network 'in memory' should be indispensable for those wanting to edit a network programatically. =genet= provides an interface to work with the network as an 'object' in a python session, including inside a Jupyter notebook, so it can be used as an interactive tool in a python REPL. However, as mentioned previously, its batch processing abilities are lacking, both due to bugs in the code and the high memory usage compared to the Java tools.

=pt2matsim= was the most reliable of any of the tools, in that it never crashed (other than when it received my poor configuration), it ran quickly and without taking up too much memory on the machine (~4GB compared to sometimes 10GB in =genet= operations). It is able to be used from the command-line for batch processing and provides reasonable defaults for each setting, for whichever task its used for. Installation and usage was, however, poorly explained in the official documentation[fn:2]. The documentation is aimed at Java developers and isn't so friendly for beginners.

Using the =MATSim= base tools was more of a hassle than the others. It involves a lot of ceremony and interaction with external tools in order to do things which are otherwise quickly done from the command line in =genet= or =pt2matsim=. Once the initial setup was done, however, it proved to be effective and quick for cleaning & simplification.

    # some talk about the statistics
The cleaning functions are similar between the tools (see section [[Cleaning and Simplification results]]). The

# limitations
    # no 'isBlocking'
As mentioned in the literature review, =MATSim= (the model) can use the fact that a stop-facility along a route is blocking the road when the bus stops. Unfortunately, this attribute is not able to be included using any of the tools reviewed here. Ideally this attribute would be included in the =stops.txt= file in a GTFS feed.

# issues encountered
    # Genet issues (list) (done)
    # RAM and speed (done)
    # CRS problems, their consequences
    # straight-line links on train networks (done)
A large issue encountered during processing steps was that specifying the wrong CRS did not ever lead to an explicit error or crash. The CRS value passed to any of the tools must also match the CRS which the network is referenced to. For example, passing the wrong CRS to =pt2matsim= at the 'generation' stage resulted in a network which appeared normal in visualisations, but whose links had very small lengths. Passing the wrong CRS to the =MATSim= cleaning & simplification tools resulted in completely empty networks. It was obvious that something was wrong, but it wasn't clear that the wrong CRS was being used. When trying to re-project to a different CRS using the RMIT tool, the output was the same as though no projection step were requested. When the wrong CRS was given to the =pt2matsim= router, it took an exceedingly long time to process anything, which led to the (false) conclusion that the input network was too large, since we had no idea how long it should 'actually' take to do the routing.

The GTFS feed available from PTV is (naturally) for the whole of Victoria. This was an issue since the OSM data only only covered the greater melbourne region. =pt2matsim= tried to create routes in these areas anyway, slowing down computation and producing unwanted output. In future works it is necessary to investigate whether the extent of the GTFS data can be clipped, removing services with stops in areas outside the OSM region.

# future work, pipeline impementation
    # need to unify process
The process covered in this paper is disjointed, with lots of manual work and tweaking involved in getting the full pipeline to run (from generation through to routing). There isn't a single tool that contains every function necessary to achieve a fully mapped PT network without manual intervention and toil. It should be possible to create a =make= script to achieve this goal, however the fact that the =MATSim= tools are 'siloed' within that ecosystem may prove to exclude them from this proposed automated pipeline.
    # need to pick 'the best tool'
    # have to limit GTFS extent (done)
    # on shapefiles for validation (done)
The validation shown in this report (section [[Checking PT routes]]) is naive and can only be used as a visual check of the results. It should be possible to use the =shapes.txt=[fn:3] file contained in the GTFS feed to verify the path chosen by the routing implementation for a given transit line. The =shapes.txt= file contains the shape of the path travelled by a given PT line or service. It is not referenced to links on a network and is normally used to show the route in a trip planning app (like the PTV app or Apple Maps).
# possibility of using shapefiles? (done)
    # on shapefiles for routing use
* Risk management plan
+ Included as \cref{app:B}
* Sustainability plan
The likely consequences of a proposed project on the community and the environment can be positive or negative. To be proactive in addressing risks to the environment, society and the economy, we need to consider how the project will impact each of these areas. We can add value to ecological, social, and economic wellness by considering how the project will impact each of these areas positively.

We can  take into account some of the key insights of technological innovation. Technology improves the effectiveness of systems in certain situations. We can mitigate unintended effects of technological innovation by making the most of the potential benefits. The risk of system failure resulting from technological innovation is particularly important in situations where the systems may not meet our needs or our operational needs.

Our decision making will be guided by technology. We can learn from technological innovation, but we must use technology to improve the performance of our systems and services. The process is complex and it is not clear how a new technology can be deployed safely or optimally

Our efforts will not be limited to the design, production and evaluation of new technologies. The process of developing technologies will include learning and applying principles of sustainability.  Our goal in this context is to ensure that technologies have the ability to help enhance outcomes for all people. The key to understanding how to improve the road network is to understand what people actually need.

A key focus in the project is the improvement of the road way we model road networks, with a focus on public transport modes. This should bring positive effects  to society in terms of reduced car usage and improved public transport.
The project is designed to help people adapt to the effects of climate change, which is one of the nine planetary boundaries. Pollution from cars and personal transport is one of the leading causes of climate change. Improvements in the road network  will be made, and the use of public transport will be encouraged. A public transport network which is better designed will be better utilised, meaning less cars will use the road and people will switch to a more sustainable form of transport, such as trains and buses. The project will help people to reduce their reliance on cars, and to switch to using cleaner forms of transport. The project will also help to reduce greenhouse gas emissions, which contributes to climate change. By helping people adapt to the effects of climate change, the project will also help to protect biodiversity and ecosystems.

Better models for road networks can aid policy decisions  on spending and maintenance, and can even help to create more sustainable solutions in this respect. Less money and time spent on maintenance and materials means that less emissions and by-products are created.

Reduction of reliance on cars will also improve communities by reducing traffic, encouraging walking and building local connections as a result. The walk-ability of a place is directly influenced by the interaction between different traffic streams. The strength of a community is improved by the interaction resulting from increased use of active transport.
* Footnotes
[fn:6]https://github.com/arup-group/genet

[fn:5]Polylines show the shape of the route, from the first to last stop, including links in-between stops
[fn:4]https://github.com/matsim-org/pt2matsim

[fn:3]https://developers.google.com/transit/gtfs/reference#shapestxt
[fn:2]https://github.com/matsim-org/pt2matsim/wiki

[fn:1] the =MATSim= tools must be used inside of a =MATSim= project, which requires loading the controler and doing things with a 'scenario' rather than just being able to accept the network file (or other files) as inputs, as a batch process normally would.
#
#+latex:\pagebreak
* References
#+print_bibliography:
#+latex:\pagebreak
#+LaTeX: \appendix
* Appendices
** Plan and timeline
#+latex: \label{app:A}
#
#+caption: Project timeline
#+label: fig:timeline
#+ATTR_LATEX: :float nil
[[./img/timeline.png]]
** Risk management
#+latex: \label{app:B}
#
#+caption: Risk management plan
#+label: fig:risk
#+ATTR_LATEX: :float nil
[[./img/risk.png]]
